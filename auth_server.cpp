/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "auth.h"
#include "token.h"
#include <fstream>
#include <sstream>
#include <iostream>
#include "auth_server_shared.h"

using namespace std;

void parse_permissions(string line, Client& client) {
	unordered_map<string, string> permissions;
	stringstream ss(line);
	string resource, permission;

	while (getline(ss, resource, ',')) {
		getline(ss, permission, ',');
		if (resource == "*")
			break;
		permissions[resource] = permission;
	}

	client.permissions = permissions;
}

bool check_permission(string permissions, string action) {
	char needed;
	if (action == "READ") {
		needed = 'R';
	} else if (action == "INSERT") {
		needed = 'I';
	} else if (action == "MODIFY") {
		needed = 'M';
	} else if (action == "DELETE") {
		needed = 'D';
	} else if (action == "EXECUTE") {
		needed = 'X';
	} else {
		return false;
	}
	for (auto &c: permissions) {
		if (c == needed) {
			return true;
		}
	}
	return false;
}

bool resource_exists(string res) {
	for (auto &r : resources) {
		if (r == res) {
			return true;
		}
	}
	return false;
}

void print_approval_message(bool approve, string action, string resource, string access_token, int operations_left) {
	string aprove_message(approve ? "PERMIT (" : "DENY (" );
	
	cout << aprove_message << action << "," << resource << "," << access_token << "," << operations_left <<")\n";
}

response *
afisare_1_svc(request *argp, struct svc_req *rqstp)
{
	static response result;
	static string res_str;
	static int req_op_index = 0;

	string action(argp->action), id(argp->id), res(argp->res);

	if (action == "REQUEST") {
		cout << "BEGIN " << id << " AUTHZ" << '\n';
		if (clients.find(id) == clients.end()) {
			res_str = "USER_NOT_FOUND";
		} else {
			Client& client = clients[id];
			
			parse_permissions(approvals_lines[req_op_index++], client);

			client.req_token = generate_access_token(argp->id);
			cout << "  RequestToken = " << client.req_token << "\n";
			if (!client.permissions.size()) {
				res_str = "REQUEST_DENIED";
			} else {
				client.access_token = generate_access_token((char *)client.req_token.c_str());
				res_str = client.req_token + " -> " + client.access_token;
				cout << "  AccessToken = " << client.access_token << '\n';
				client.lifetime = token_lifetime;
				client.auto_refresh = false;
				if (res == "1") {
					client.auto_refresh = true;
					client.refresh_token = generate_access_token((char *) client.access_token.c_str());
					res_str += "," + client.refresh_token;
					cout << "  RefreshToken = " << client.refresh_token << '\n';
				}
			}
		}
	} else {
		if (clients.find(id) == clients.end()) {
			res_str = "USER_NOT_FOUND";
		} else {
			Client& client = clients[id];
			if (client.req_token == "") {
				print_approval_message(false, action, res, "", 0);

				res_str = "PERMISSION_DENIED";
			} else {
				if (client.lifetime == 0) {
					if (client.auto_refresh) {
						client.access_token = generate_access_token((char *)client.refresh_token.c_str());
						client.refresh_token = generate_access_token((char *) client.access_token.c_str());
					
						client.lifetime = token_lifetime;

						cout << "BEGIN " << id << " AUTHZ REFRESH" << '\n';
						cout << "  AccessToken = " << client.access_token << '\n';
						cout << "  RefreshToken = " << client.refresh_token << '\n';
				} else {
						client.req_token = "";
						client.access_token = "";
					}
				}
			

				if (client.lifetime == 0) {
					// todo
					print_approval_message(false, action, res, client.access_token, client.lifetime);
					res_str = "TOKEN_EXPIRED";
				} else if (!resource_exists(res)) {
					// todo
					print_approval_message(false, action, res, client.access_token, --client.lifetime);
					res_str = "RESOURCE_NOT_FOUND";
				} else if (check_permission(client.permissions[res], action)) {
					
					print_approval_message(true, action, res, client.access_token, --client.lifetime);
					res_str = "PERMISSION_GRANTED";
					
				} else {
					print_approval_message(false, action, res, client.access_token, --client.lifetime);
					res_str = "OPERATION_NOT_PERMITTED";
				}
			}
		}
	}
	fflush(stdout);
	strncpy(result.msg, res_str.c_str(), sizeof(result.msg));
	return &result;
}